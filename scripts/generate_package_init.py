import os
import sys
import argparse
import logging
from pathlib import Path
from typing import List

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def get_server_names(servers_dir: Path) -> List[str]:
    """
    Scans the servers directory and returns a list of valid server names.
    A server is valid if it's a directory, not starting with '__',
    not 'simple-tools-server', and contains a 'main.py' file.
    """
    valid_server_names: List[str] = []
    if not servers_dir.exists() or not servers_dir.is_dir():
        logger.error(f"Servers directory not found or is not a directory: {servers_dir}")
        return valid_server_names

    for item_name in sorted(os.listdir(servers_dir)):
        item_path = servers_dir / item_name
        main_py_path = item_path / "main.py"
        if (
            item_path.is_dir()
            and not item_name.startswith("__")
            and item_name != "simple-tools-server"  # Exclude simple-tools-server
            and main_py_path.exists()
            and main_py_path.is_file()
        ):
            valid_server_names.append(item_name)
        elif item_path.is_dir() and not item_name.startswith("__") and item_name != "simple-tools-server":
            logger.warning(f"Skipping server '{item_name}': 'main.py' not found at {main_py_path}")

    logger.info(f"Found valid servers: {valid_server_names}")
    return valid_server_names


def generate_init_content(server_names: List[str]) -> str:
    """
    Generates the content for the __init__.py file.
    """
    if not server_names:
        return """# Generated by scripts/generate_package_init.py. DO NOT EDIT.
# flake8: noqa
# fmt: off

# No valid servers found.

__all__ = []

# fmt: on
"""

    lines: List[str] = [
        "# Generated by scripts/generate_package_init.py. DO NOT EDIT.",
        "# flake8: noqa",
        "# fmt: off",
        "",
    ]

    import_statements: List[str] = []
    all_entries: List[str] = []

    for name in sorted(server_names):  # Ensure sorted order
        variable_name = f"{name}_server"
        import_statements.append(
            f"from .servers.{name}.main import server as {variable_name}"
        )
        all_entries.append(f'    "{variable_name}",')

    lines.extend(import_statements)
    lines.append("")
    lines.append("__all__ = [")
    lines.extend(all_entries)
    lines.append("]")
    lines.append("")
    lines.append("# fmt: on")
    lines.append("")  # Add a trailing newline

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Generate the src/gumcp/__init__.py file with server exports."
    )
    parser.add_argument(
        "--output",
        "-o",
        default="src/gumcp/__init__.py",
        help="Path where the __init__.py file should be saved (default: src/gumcp/__init__.py)",
    )
    args = parser.parse_args()

    try:
        script_dir = Path(__file__).parent.resolve()
        root_dir = script_dir.parent
        servers_dir = root_dir / "src" / "gumcp" / "servers"
        output_file = root_dir / args.output # Ensure output path is relative to root_dir if not absolute

        logger.info(f"Root directory: {root_dir}")
        logger.info(f"Servers directory: {servers_dir}")
        logger.info(f"Output file: {output_file}")

        server_names = get_server_names(servers_dir)

        if not server_names:
            logger.warning("No valid servers found. __init__.py will be generated with an empty __all__ list.")
            # Still generate the file so it's clear no servers were found, or it's reset
        
        init_content = generate_init_content(server_names)

        output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(output_file, "w") as f:
            f.write(init_content)

        logger.info(f"Successfully generated __init__.py at: {output_file}")
        logger.info(f"Total servers included: {len(server_names)}")
        sys.exit(0)

    except Exception as e:
        logger.error(f"Failed to generate __init__.py: {str(e)}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main()
